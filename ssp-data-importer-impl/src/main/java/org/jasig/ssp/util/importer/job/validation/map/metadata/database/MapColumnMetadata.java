/**
 * Licensed to Jasig under one or more contributor license
 * agreements. See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Jasig licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a
 * copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.jasig.ssp.util.importer.job.validation.map.metadata.database;

import java.math.BigDecimal;
import java.sql.Time;
import java.sql.Types;

import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.apache.commons.lang3.time.DateUtils;
import org.jarbframework.constraint.metadata.database.ColumnMetadata;
import org.jarbframework.utils.Asserts;
import org.jarbframework.utils.orm.ColumnReference;
import org.jasig.ssp.util.importer.job.validation.map.metadata.utils.MapReference;
import org.jasig.ssp.util.importer.job.validation.map.metadata.validation.DatabaseConstraintMapValidationContext;
import org.jasig.ssp.util.importer.job.validation.map.metadata.validation.MapViolation;
import org.jasig.ssp.util.importer.job.validation.map.metadata.validation.violation.UnableToParseMapViolation;

public class MapColumnMetadata extends ColumnMetadata {

    /** Reference to the column **/
    private final ColumnReference columnReference;

    /** Determines if a not-null value is required **/
    private boolean required;
    /** Determines if the database can auto increment **/
    private boolean autoIncrement;
    /** Describes the default value of our column **/
    private String defaultValue;
    /** Maximum length of the column **/
    private Integer maximumLength;
    /** Number radix, only used for numeric values **/
    private Integer radix;
    /** Number of fractional digits, only for numeric values **/
    private Integer fractionLength;
    /** Stored Java Sql Type for validation of conversion to type*/
    private Integer javaSqlType;

    /**
     * Construct a new {@link ColumnMetadata}.
     * @param columnReference reference to the column
     */
    public MapColumnMetadata(ColumnReference columnReference) {
        super(columnReference);
        this.columnReference = Asserts.notNull(columnReference, "Column reference cannot be null");
    }

    /**
     * Retrieve the column that we are describing.
     * @return column reference
     */
    public ColumnReference getColumnReference() {
        return columnReference;
    }

    public String getTableName() {
        return columnReference.getTableName();
    }

    public String getColumnName() {
        return columnReference.getColumnName();
    }

    /**
     * Determine if this column is required, whenever {@code true}
     * a not-null value is required.
     * @return {@code true} if required, else {@code false}
     */
    public boolean isRequired() {
        return required;
    }

    public void setRequired(boolean required) {
        this.required = required;
    }

    /**
     * Determine if default column values can be generated by the database.
     * @return {@code true} if values can be generated, else {@code false}
     */
    public boolean isAutoIncrement() {
        return autoIncrement;
    }

    public void setAutoIncrement(boolean autoIncrement) {
        this.autoIncrement = autoIncrement;
    }

    /**
     * Column values can be generated if the column has a default value it can use, or
     * an auto increment has been specified.
     * @param columnMetadata provides column information
     * @return {@code true} if the column value can be generated, else {@code false}
     */
    public boolean isGeneratable() {
        return hasDefaultValue() || isAutoIncrement();
    }

    /**
     * Determine if the column has a default value, used whenever no value
     * has been provided during the insert statement.
     * @return {@code true} if a default value is specified, else {@code false}
     */
    public boolean hasDefaultValue() {
        return defaultValue != null;
    }

    public Object getDefaultValue() {
        return defaultValue;
    }

    public void setDefaultValue(String defaultValue) {
        this.defaultValue = defaultValue;
    }

    /**
     * Determine if our column has a maximum length. Whenever a column has no
     * maximum length, {@link #getMaximumLength()} always returns {@code null}.
     * @return {@code true} if the column has a maximum length, else {@code false}
     */
    public boolean hasMaximumLength() {
        return maximumLength != null;
    }

    /**
     * Retrieve the maximum length of a column, if any.
     * @return maximum length, if any
     */
    public Integer getMaximumLength() {
        return maximumLength;
    }

    public void setMaximumLength(Integer maximumLength) {
        this.maximumLength = maximumLength;
    }

    /**
     * Retrieve the radix of a number.
     * @return number radix
     */
    public Integer getRadix() {
        return radix;
    }

    public void setRadix(Integer radix) {
        this.radix = radix;
    }

    /**
     * Determine if our column has a maximum fraction length, meaning the number
     * of digits behind the comma. Fraction length restrictions are possible on
     * numeric column types, such as {@code double} or {@code numeric}. Whenever
     * a column has no maximum fraction length, {@link #getFractionLength()}
     * will always result in {@code null}.
     * @return {@code true} if the column has a maximum fraction length, else {@code false}
     */
    public boolean hasFractionLength() {
        return fractionLength != null;
    }

    /**
     * Retrieve the maximum fraction length, if any. Fraction length describes the
     * number of digits behind the comma. Fraction length restrictions are possible
     * on numeric column types, such as {@code double} or {@code numeric}.
     * @return maximum fraction length, if any
     */
    public Integer getFractionLength() {
        return fractionLength;
    }

    public void setFractionLength(Integer fractionLength) {
        this.fractionLength = fractionLength;
    }

    public Integer getJavaSqlType() {
        return javaSqlType;
    }

    public void setJavaSqlType(Integer javaSqlType) {
        this.javaSqlType = javaSqlType;
    }

    @Override
    public boolean equals(Object obj) {
        boolean equals = false;
        if (obj instanceof ColumnMetadata) {
            equals = columnReference.equals(((ColumnMetadata) obj).getColumnReference());
        }
        return equals;
    }

    @Override
    public int hashCode() {
        return columnReference.hashCode();
    }

    public Object convertValueToType(String columnValue, MapReference mapReference, DatabaseConstraintMapValidationContext validation){
        Object propertyValue = null;
        String typeAsString = "";
        if(columnValue != null){
            try{
            switch(javaSqlType){
                case Types.BIGINT:
                    typeAsString = "BIGINT";
                    propertyValue = Long.parseLong(columnValue);
                    break;
                case Types.INTEGER:
                    typeAsString = "INTEGER";
                    propertyValue = Integer.parseInt(columnValue);
                    break;
                case Types.DECIMAL:
                     typeAsString = "DECIMAL";
                case Types.DOUBLE:
                     typeAsString = "DOUBLE";
                case Types.FLOAT:
                     typeAsString = "FLOAT";
                case Types.NUMERIC:
                    typeAsString = "NUMERIC";
                    propertyValue = new BigDecimal(columnValue);
                    break;

                case Types.DATE:
                    typeAsString = "DATE";
                    propertyValue = DateUtils.parseDateStrictly(columnValue, DATE_PATTERNS);
                    break;
                case Types.TIMESTAMP:
                    typeAsString = "TIMESTAMP";
                    propertyValue = new java.sql.Timestamp(Long.getLong(columnValue));
                    break;
                case Types.TIME:
                    typeAsString = "TIME";
                    propertyValue = new Time( DateUtils.parseDateStrictly(columnValue, TIME_PATTERNS).getTime());
                    break;
                default:
                    typeAsString = javaSqlType.toString();
                    propertyValue = columnValue;
                    break;

            }
            }catch(Exception exception){
                validation.addViolation(new UnableToParseMapViolation(mapReference, columnValue, typeAsString));
                propertyValue = columnValue;
            }

        }
        return propertyValue;
    }

    /**
     * Date format pattern used to parse HTTP date headers in RFC 1123 format.
     */
    private static final String PATTERN_RFC1123 = "EEE, dd MMM yyyy HH:mm:ss zzz";
    private static final String PATTERN_RFC1036 = "EEEE, dd-MMM-yy HH:mm:ss zzz";
    private static final String PATTERN_ASCTIME = "EEE MMM d HH:mm:ss yyyy";

    private static final String PATTERN_BIRTH_DATE_1 = "yyyy-MM-dd";
    private static final String PATTERN_BIRTH_DATE_2 = "MM/dd/yy";

    private static final String PATTERN_TERM_DATE_1 = "MM/dd/yyyy HH:mm:ss";
    private static final String PATTERN_TERM_DATE_2 = "MM/dd/yyyy HH:mm";
    private static final String PATTERN_TERM_DATE_3 = "yyyy-MM-dd HH:mm:ss";
    private static final String PATTERN_TERM_DATE_4 = "MM-dd-yyyy HH:mm:ss";


    private static final String[] DATE_PATTERNS = new String[] {
        PATTERN_RFC1036,
        PATTERN_RFC1123,
        PATTERN_ASCTIME,
        PATTERN_BIRTH_DATE_1,
        PATTERN_BIRTH_DATE_2,
        PATTERN_TERM_DATE_1,
        PATTERN_TERM_DATE_2,
        PATTERN_TERM_DATE_3,
        PATTERN_TERM_DATE_4
    };

    private static final String TIME_PATTERN = "hh:mm:ss a";

    private static final String[] TIME_PATTERNS = new String[]{TIME_PATTERN};

    @Override
    public String toString() {
        return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);
    }
}
